<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sphinx - Substrate Mix Network Specification</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="conventions-and-definitions.html"><strong aria-hidden="true">2.</strong> Conventions and definitions</a></li><li class="chapter-item expanded "><a href="sessions.html"><strong aria-hidden="true">3.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="topology.html"><strong aria-hidden="true">4.</strong> Topology</a></li><li class="chapter-item expanded "><a href="blockchain-runtime-interface.html"><strong aria-hidden="true">5.</strong> Blockchain runtime interface</a></li><li class="chapter-item expanded "><a href="networking.html"><strong aria-hidden="true">6.</strong> Networking</a></li><li class="chapter-item expanded "><a href="sphinx.html" class="active"><strong aria-hidden="true">7.</strong> Sphinx</a></li><li class="chapter-item expanded "><a href="message-fragmentation.html"><strong aria-hidden="true">8.</strong> Message fragmentation</a></li><li class="chapter-item expanded "><a href="requests-and-replies.html"><strong aria-hidden="true">9.</strong> Requests and replies</a></li><li class="chapter-item expanded "><a href="cover-traffic.html"><strong aria-hidden="true">10.</strong> Cover traffic</a></li><li class="chapter-item expanded "><a href="parameters.html"><strong aria-hidden="true">11.</strong> Parameters</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Substrate Mix Network Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sphinx"><a class="header" href="#sphinx">Sphinx</a></h1>
<p>Substrate Mix Networks use a packet format based on
<a href="https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf">Sphinx</a>.</p>
<h2 id="packet-structure"><a class="header" href="#packet-structure">Packet structure</a></h2>
<p>All packets are the same size: 2,252 bytes. These bytes are split as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Bytes</th><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>0..31</td><td><code>kx_public</code></td><td>X25519 public key, α in the Sphinx paper</td></tr>
<tr><td>32..47</td><td><code>mac</code></td><td>MAC, γ in the Sphinx paper</td></tr>
<tr><td>48..187</td><td><code>actions</code></td><td>Encrypted routing actions, β in the Sphinx paper</td></tr>
<tr><td>188..2251</td><td><code>payload</code></td><td>Encrypted payload, δ in the Sphinx paper</td></tr>
</tbody></table>
</div>
<p>The <code>kx_public</code>, <code>mac</code>, and <code>actions</code> fields together form the header.</p>
<h2 id="key-exchange"><a class="header" href="#key-exchange">Key exchange</a></h2>
<p>The X25519 public key <code>kx_public</code> is combined with the receiving node's X25519 secret key for the
session <code>recv_kx_secret</code> to produce a 32-byte shared secret <code>kx_shared_secret</code>:</p>
<pre><code>kx_shared_secret = Curve25519(recv_kx_secret, kx_public)
</code></pre>
<p>The same shared secret can be derived by combining the secret key corresponding to <code>kx_public</code>,
<code>kx_secret</code>, with the receiving node's public key <code>recv_kx_public</code>:</p>
<pre><code>kx_shared_secret = Curve25519(kx_secret, recv_kx_public)
</code></pre>
<p>Note that <code>kx_public</code> bears no relation to the source node's X25519 key pair for the session; the
corresponding secret key is <a href="#key-generation">randomly generated per packet</a>.</p>
<h2 id="secret-derivation"><a class="header" href="#secret-derivation">Secret derivation</a></h2>
<p>From the 32-byte shared secret, a number of other secrets are derived:</p>
<ul>
<li>A 32-byte X25519 blinding factor <code>kx_blinding_factor</code>.</li>
<li>A 16-byte MAC key <code>mac_key</code>.</li>
<li>A 32-byte routing actions encryption key <code>actions_encryption_key</code>.</li>
<li>A 16-byte forwarding delay seed <code>delay_seed</code>.</li>
<li>A 192-byte payload encryption key <code>payload_encryption_key</code>.</li>
</ul>
<p>These are derived as follows:</p>
<pre><code>kx_blinding_factor = clamp_scalar(
    blake2b(&quot;sphinx-blind-fac&quot;, 0, kx_public ++ kx_shared_secret)[..32])

mac_key ++ actions_encryption_key ++ delay_seed =
    blake2b(&quot;sphinx-small-d-s&quot;, 0, kx_shared_secret)

payload_encryption_key =
    blake2b(&quot;sphinx-pl-en-key&quot;, 0, kx_shared_secret) ++
    blake2b(&quot;sphinx-pl-en-key&quot;, 1, kx_shared_secret) ++
    blake2b(&quot;sphinx-pl-en-key&quot;, 2, kx_shared_secret)
</code></pre>
<h2 id="mac-verification"><a class="header" href="#mac-verification">MAC verification</a></h2>
<p><code>mac</code> should equal the BLAKE2b hash of <code>actions</code> computed with the key <code>mac_key</code>.</p>
<p>The receiving node determines the packet's session by which X25519 secret key results in the hash
equalling <code>mac</code>. If neither the previous nor current session key results in a hash equalling <code>mac</code>,
the packet is simply dropped.</p>
<h2 id="routing-actions"><a class="header" href="#routing-actions">Routing actions</a></h2>
<p>The routing actions in <code>actions</code> dictate how the packet should be routed. There should be a
&quot;forward&quot; action for each intermediate node, followed by a single &quot;deliver&quot; action for the final
node.</p>
<p>Actions are two-byte little-endian unsigned integers, with some actions being followed by
additional data:</p>
<div class="table-wrapper"><table><thead><tr><th>Action</th><th>Description</th><th>Additional data</th></tr></thead><tbody>
<tr><td>&lt; 0xff00</td><td>Forward to the mixnode with this index</td><td>16-byte MAC</td></tr>
<tr><td>0xff00</td><td>Forward to the node with the given peer ID</td><td>32-byte peer ID, 16-byte MAC</td></tr>
<tr><td>0xff01</td><td>Deliver request packet</td><td>None</td></tr>
<tr><td>0xff02</td><td>Deliver reply packet</td><td>16-byte SURB ID</td></tr>
<tr><td>0xff03</td><td>Deliver cover packet</td><td>None</td></tr>
<tr><td>0xff04</td><td>Deliver cover packet with ID</td><td>16-byte cover ID</td></tr>
<tr><td>&gt; 0xff04</td><td>Invalid</td><td>N/A</td></tr>
</tbody></table>
</div>
<p>Actions are tightly packed, with the first two bytes of <code>actions</code> giving the first action.</p>
<p><code>actions</code> is encrypted with the ChaCha20 stream cipher, keyed by <code>actions_encryption_key</code>, using a
nonce of zero. Actions past the first are encrypted further with different keys; only the first
action can be fully decrypted by the receiving node.</p>
<h3 id="forward-actions"><a class="header" href="#forward-actions">Forward actions</a></h3>
<p>If the first action is a forward action, and the receiving node is a mixnode in the session, it
should attempt to forward the packet to the specified node. If the receiving node is not a mixnode,
the packet should be discarded. Before forwarding, the packet should be artificially delayed, and
transformed.</p>
<p>The artificial delay should be calculated as <code>exp_random(delay_seed) * mean_delay</code>, where
<code>mean_delay</code> is the mean forwarding delay (see the <a href="./parameters.html">parameters chapter</a>).</p>
<p>The packet should be transformed as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Transformation</th></tr></thead><tbody>
<tr><td><code>kx_public</code></td><td>Replace with <code>Curve25519(kx_blinding_factor, kx_public)</code></td></tr>
<tr><td><code>mac</code></td><td>Replace with the MAC following the forward action</td></tr>
<tr><td><code>actions</code></td><td>Extend with zero bytes, decrypt, then drop the first action</td></tr>
<tr><td><code>payload</code></td><td>Decrypt using <code>payload_encryption_key</code></td></tr>
</tbody></table>
</div>
<p>Note that:</p>
<ul>
<li>The number of zero bytes appended to <code>actions</code> should match the length of the first action (2
plus the length of any additional data); after dropping the first action the total length should
match the original length prior to extension.</li>
<li>Decryption of the extended <code>actions</code> simply means XORing with the ChaCha20 keystream derived from
<code>actions_encryption_key</code>.</li>
</ul>
<p>In the forward-to-peer-ID case, the peer ID is a raw 32-byte Ed25519 public key.</p>
<h3 id="deliver-actions"><a class="header" href="#deliver-actions">Deliver actions</a></h3>
<p>If the first action is a deliver action, the packet is destined for the receiving node.</p>
<p>If the packet is a cover packet, it should simply be discarded.</p>
<p>If the packet is a request packet, and the receiving node is a mixnode in the session, the payload
should be decrypted using <code>payload_encryption_key</code>. If the receiving node is <em>not</em> a mixnode, the
packet should be discarded.</p>
<p>If the packet is a reply packet, the receiving node should lookup and remove the payload encryption
keys corresponding to the SURB ID from its SURB keystore. If the keys are not found, the packet
should be discarded. Otherwise, the keys should be used, one at a time in reverse order, to
<em>encrypt</em> the payload. See <a href="#surbs">the SURBs section below</a> for more on SURBs.</p>
<p>After decryption/encryption of a request/reply payload, if the last 16 bytes of the payload are 0,
the rest of the payload should be handled as a <a href="./message-fragmentation.html#fragment-structure">message
fragment</a>. If the last 16 bytes are not all 0, the
packet is invalid and should be discarded.</p>
<h3 id="invalid-actions"><a class="header" href="#invalid-actions">Invalid actions</a></h3>
<p>If the first action is invalid, the receiving node should discard the packet.</p>
<h2 id="payload-encryption"><a class="header" href="#payload-encryption">Payload encryption</a></h2>
<p>The LIONESS cipher, instantiated with BLAKE2b as the hash function and ChaCha20 as the stream
cipher, is used for payload encryption. LIONESS is described in detail in <a href="https://www.cl.cam.ac.uk/~rja14/Papers/bear-lion.pdf">Two Practical and
Provably Secure Block Ciphers: BEAR and
LION</a>.</p>
<p>Encryption keys, such as <code>payload_encryption_key</code>, are the concatenation of K<sub>1</sub>,
K<sub>2</sub>, K<sub>3</sub>, and K<sub>4</sub> (see the linked paper), with K<sub>1</sub> and
K<sub>3</sub> being 32 bytes, and K<sub>2</sub> and K<sub>4</sub> being 64 bytes.</p>
<p>The ChaCha20 stream cipher is initialised with a zero nonce.</p>
<p>The <a href="https://crates.io/crates/lioness"><code>lioness</code> crate on <code>crates.io</code></a> provides a compatible
implementation.</p>
<h2 id="replay-filtering"><a class="header" href="#replay-filtering">Replay filtering</a></h2>
<p>If a node receives multiple packets which have the same <code>kx_shared_secret</code>, it must avoid
forwarding or delivering more than one of them. Note that:</p>
<ul>
<li>When a secret key is discarded (eg due to a session switch), all shared secrets which were
derived from the secret key may be forgotten.</li>
<li>If a packet is discarded before being forwarded or delivered, its shared secret need not be
remembered.</li>
<li>It is not necessary to record reply packet shared secrets, as the lookup in the SURB keystore
will fail for replayed SURBs. Further, as cover packets are simply discarded, and request and
forward packets are not accepted by non-mixnodes, if a node is never a mixnode, it need not do
any explicit replay filtering.</li>
<li>It is expected that nodes will use a probabilistic data structure, such as a bloom filter, to
record which shared secrets have been derived from each secret key. The false-negative rate of
the data structure should be zero. The false-positive rate should be below 1% (ie there should be
at most 1% packet loss caused by faulty filtering). Shared secret hashes should be cryptographic,
and keyed to avoid DoS attacks.</li>
</ul>
<h2 id="packet-construction"><a class="header" href="#packet-construction">Packet construction</a></h2>
<p>This section covers the construction of request and cover packets. Reply packet construction is
slightly different as it is split into two parts, which take place on different nodes: SURB
construction (receiving node) and SURB use (sending node). This is covered in the <a href="#surbs">SURBs section
below</a>.</p>
<h3 id="key-generation"><a class="header" href="#key-generation">Key generation</a></h3>
<p>The first step in constructing a Sphinx packet is key generation. An X25519 key pair should be
generated as follows:</p>
<pre><code>kx_secret = clamp_scalar(random())
kx_public = Curve25519(kx_secret, 9)
</code></pre>
<p>Where:</p>
<ul>
<li><code>random()</code> generates 32 random bytes.</li>
<li><code>9</code>, the X25519 base point, is little-endian encoded.</li>
</ul>
<h3 id="shared-secret-computation"><a class="header" href="#shared-secret-computation">Shared secret computation</a></h3>
<p>The shared secrets can then be computed incrementally:</p>
<pre><code>kx_secrets[0] = kx_secret
kx_shared_secrets[i] = Curve25519(kx_secrets[i], recv_kx_publics[i])
kx_publics[i] = Curve25519(kx_secrets[i], 9)
kx_secrets[i + 1] = (kx_blinding_factors[i] * kx_secrets[i]) % order
</code></pre>
<p>Where:</p>
<ul>
<li><code>recv_kx_publics[i]</code> is the X25519 public key of the <code>i</code>th node in the route (excluding the
source node).</li>
<li><code>kx_blinding_factors[i]</code> is computed from <code>kx_publics[i]</code> and <code>kx_shared_secrets[i]</code> as described
<a href="#secret-derivation">above</a>.</li>
<li><code>order</code> is 2<sup>252</sup> + 27742317777372353535851937790883648493; the order of the group
generated by the X25519 base point.</li>
</ul>
<h3 id="routing-actions-1"><a class="header" href="#routing-actions-1">Routing actions</a></h3>
<p>Generating the encrypted routing actions (<code>actions</code>) is non-trivial; the MACs attached to the
forward actions depend on the &quot;padding&quot; (encrypted zeroes) the receiving nodes will see. One method
is as follows:</p>
<ul>
<li>Write the routing actions, unencrypted, into <code>actions</code>. Leave any MACs uninitialised. Fill any
unused bytes with random data.</li>
<li>Compute the padding that each node along the route will observe on packet arrival. The length at
each node should match the total length of all earlier actions. The padding is generated by
zero-extension and encryption at each node along the route; it can be determined from the action
sizes and <code>kx_shared_secrets</code>.</li>
<li>For each action, in reverse order:
<ul>
<li>Encrypt all bytes from the start of the action to the end of <code>actions</code>, using the encryption
key for the node that will process the action.</li>
<li>Compute the MAC of the concatenation of the just-encrypted part of <code>actions</code> with the
corresponding padding computed in the second step, using the MAC key for the node that will
process the action. In the case of the first action, write the MAC to <code>mac</code>; for other actions,
write it into <code>actions</code> immediately before the action.</li>
</ul>
</li>
</ul>
<p>Whichever method is used, it is important that any unused decrypted data the final node sees is
indistinguishable from random. If this is not the case, the final node may be able to infer the
route length. The above method achieves this by filling unused bytes with random data in the first
step.</p>
<p>Note that the 140-byte <code>actions</code> is just large enough to handle the <a href="./topology.html#route-generation">worst case
route</a>:</p>
<ul>
<li>4 forward-to-mixnode actions (18 bytes each, 72 bytes total).</li>
<li>One forward-to-peer-ID action (50 bytes).</li>
<li>One deliver action with a 16-byte ID (18 bytes).</li>
</ul>
<h3 id="payload"><a class="header" href="#payload">Payload</a></h3>
<p>Constructing <code>payload</code> is straightforward. For cover packets, simply fill <code>payload</code> with random
bytes. For request packets:</p>
<ul>
<li>Write zeroes to the last 16 bytes. Write the unencrypted <a href="./message-fragmentation.html#fragment-structure">message
fragment</a> to the other bytes.</li>
<li><a href="#secret-derivation">Derive the payload encryption keys</a> for the nodes along the route from
<code>kx_shared_secrets</code>.</li>
<li>Encrypt <code>payload</code> using each encryption key, in reverse order (starting with the encryption key
for the destination node).</li>
</ul>
<h2 id="surbs"><a class="header" href="#surbs">SURBs</a></h2>
<p>A SURB (single-use reply block) can be used to send a reply packet to the node that generated it.
As the name suggests, each SURB should only be used once. SURBs are always 222 bytes, split as
follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Bytes</th><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>0..1</td><td><code>first_mixnode_index</code></td><td>Little-endian index of the first mixnode in the route</td></tr>
<tr><td>2..189</td><td><code>header</code></td><td>Prefabricated Sphinx header</td></tr>
<tr><td>190..221</td><td><code>shared_secret</code></td><td>Secret to derive the first payload encryption key from</td></tr>
</tbody></table>
</div>
<h3 id="surb-construction"><a class="header" href="#surb-construction">SURB construction</a></h3>
<p>Equipped with a <a href="./topology.html#route-generation">route</a>, a node can build a SURB as follows:</p>
<ul>
<li>Set <code>first_mixnode_index</code> to the index of the first mixnode in the route, excluding the source
node.</li>
<li>Build the Sphinx header <code>header</code> as <a href="#packet-construction">normal</a>, with the last action being a
deliver reply action with a randomly generated SURB ID.</li>
<li>Randomly generate <code>shared_secret</code>.</li>
<li><a href="#secret-derivation">Derive the payload encryption keys</a> for the nodes along the route from
<code>kx_shared_secrets</code>, excluding the source and destination nodes.</li>
<li>Derive a payload encryption key from <code>shared_secret</code> in the same way.</li>
<li>Store the payload encryption keys (the one derived from <code>shared_secret</code>, followed by the ones
derived from <code>kx_shared_secrets</code>) in the SURB keystore, keyed by the SURB ID.</li>
</ul>
<p>The payload encryption keys corresponding to a SURB ID may never get used, for example if the SURB
or the reply packet are lost. It is expected that nodes will only keep a limited number of keys,
for the most recently generated SURBs.</p>
<h3 id="surb-use"><a class="header" href="#surb-use">SURB use</a></h3>
<p>Constructing a reply packet from a SURB is straightforward:</p>
<ul>
<li>Split <code>header</code> into <code>kx_public</code>, <code>mac</code>, and <code>actions</code>.</li>
<li>Write zeroes to the last 16 bytes of <code>payload</code>. Write the unencrypted <a href="./message-fragmentation.html#fragment-structure">message
fragment</a> to the other bytes.</li>
<li>Derive a payload encryption key from <code>shared_secret</code> in the same way that
<code>payload_encryption_key</code> is derived from <code>kx_shared_secret</code> <a href="#secret-derivation">above</a>.</li>
<li><em>Decrypt</em> <code>payload</code> using the derived key.</li>
</ul>
<p>The constructed packet should be sent to the mixnode with index <code>first_mixnode_index</code>. The session
is implicit: it should match the session used by the request message containing the SURB.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="networking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="message-fragmentation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="networking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="message-fragmentation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
